:py:mod:`markovflow.conditionals`
=================================

.. py:module:: markovflow.conditionals

.. autoapi-nested-parse::

   Module for evaluating conditional distributions.



Module Contents
---------------

.. py:function:: conditional_predict(new_time_points: tensorflow.Tensor, training_time_points: tensorflow.Tensor, kernel: markovflow.kernels.SDEKernel, training_pairwise_means: tensorflow.Tensor, training_pairwise_covariances: Optional[tensorflow.Tensor] = None) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

   Given :math:`‚àÄ x‚Çú ‚àà` `new_time_points`, compute the means and
   covariances of the marginal densities:

   .. math:: p(x‚Çú) = ‚à´ d[x‚Çã, x‚Çä] p(x‚Çú|x‚Çã, x‚Çä) q(x‚Çã, x‚Çä; m‚Çú, S‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú + P‚Çú S‚Çú P‚Çú·µÄ)

   Or, if :math:`S‚Çú` is not given, compute the conditional density:

   .. math:: p(x‚Çú|[x‚Çã, x‚Çä] = m‚Çú) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)

   .. note:: `new_time_points` and `training_time_points` must be sorted.

   Where:

     - :math:`p` is the density over state trajectories specified by the kernel
     - :math:`‚àÄ x‚Çú ‚àà` `new_time_points`:

       .. math::
           x‚Çä = arg min‚Çì \{|x-x‚Çú|, x ‚àà \verb|training_time_point and |x>x‚Çú\}\\
           x‚Çã = arg min‚Çì \{|x-x‚Çú|, x ‚àà \verb|training_time_point and |x‚©Ωx‚Çú\}

   Details of the computation of :math:`P‚Çú` and :math:`T‚Çú` are found
   in :func:`conditional_statistics`.

   :param new_time_points: Sorted time points to generate observations for, with shape
           ``batch_shape + [num_new_time_points,]``.
   :param training_time_points: Sorted time points to condition on, with shape
           ``batch_shape + [num_training_time_points,]``.
   :param kernel: A kernel.
   :param training_pairwise_means: Pairs of states to condition on, with shape
           ``batch_shape + [num_training_time_points, 2 * state_dim]``.
   :param training_pairwise_covariances: Covariances of the pairs of states to condition on, with
           shape ``batch_shape + [num_training_time_points, 2 * state_dim, 2 * state_dim]``.
   :return: Predicted mean and covariance for the new time points, with respective shapes
           ``batch_shape + [num_new_time_points, state_dim]``
           ``batch_shape + [num_new_time_points, state_dim, state_dim]``.


.. py:function:: conditional_statistics(new_time_points: tensorflow.Tensor, training_time_points: tensorflow.Tensor, kernel: markovflow.kernels.SDEKernel) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

   Given :math:`‚àÄ x‚Çú ‚àà` `new_time_points`, compute the statistics :math:`P‚Çú` and :math:`T‚Çú`
   of the conditional densities:

   .. math:: p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)

   ...where:

       - :math:`p` is the density over state trajectories specified by the kernel
       - :math:`‚àÄ x‚Çú ‚àà` `new_time_points`:

         .. math::
               x‚Çä = arg min‚Çì \{ |x-x‚Çú|, x ‚àà \verb|training_time_point and |x>x‚Çú \}\\
               x‚Çã = arg min‚Çì \{ |x-x‚Çú|, x ‚àà \verb|training_time_point and |x‚©Ωx‚Çú \}

   .. note:: `new_time_points` and `training_time_points` must be sorted.

   :param new_time_points: Sorted time points to generate observations for, with shape
           ``batch_shape + [num_new_time_points,]``.
   :param training_time_points: Sorted time points to condition on, with shape
           ``batch_shape + [num_training_time_points,]``.
   :param kernel: A kernel.
   :return: Parameters for the conditional mean and covariance, with respective shapes
           ``batch_shape + [num_new_time_points, state_dim, 2 * state_dim]``
           ``batch_shape + [num_new_time_points, state_dim, state_dim]``.


.. py:function:: _conditional_statistics_from_transitions(state_transitions_to_t: tensorflow.Tensor, process_covariances_to_t: tensorflow.Tensor, state_transitions_from_t: tensorflow.Tensor, process_covariances_from_t: tensorflow.Tensor, return_precision: bool = False) -> Tuple[tensorflow.Tensor, tensorflow.Tensor, tensorflow.Tensor]

   Implementation details:
       Given consecutive time differences Œî‚ÇÅ = t - t‚Çã and Œî‚ÇÇ = t‚Çä - t
       of ordered triplets t‚Çã < t < t‚Çä, we denote their values as
       x‚Çã, x‚Çú, x‚Çä and their conditional distributions as
       p(x‚Çä | x‚Çú) = ùìù(x‚Çä; A‚Çú‚Çäx‚Çú, Q‚Çú‚Çä)    where     [A‚Çú‚Çä == A_tp, Q‚Çú‚Çä == Q_tp]
       p(x‚Çú | x‚Çã) = ùìù(x‚Çú; A‚Çã‚Çúx‚Çã, Q‚Çã‚Çú)    where     [A‚Çã‚Çú == A_mt, Q‚Çã‚Çú == Q_mt]

       This computes D‚Çú, E‚Çú, T‚Çú (or T‚Çú‚Åª¬π) such that
       p(x‚Çú | x‚Çã, x‚Çä) = ùìù(x‚Çú; D‚Çú @ x‚Çã + E‚Çú @ x‚Çä, T‚Çú)

       p(x‚Çä|x‚Çú, x‚Çã) = p(x‚Çä|x‚Çú) = ùìù(A‚Çú‚Çäx‚Çú, Q‚Çú‚Çö)
       p(x‚Çú|x‚Çã) = ùìù(A‚Çã‚Çúx‚Çã, Q‚Çã‚Çú)
       p(x‚Çä| x‚Çã) = ùìù(A‚Çã‚Çäx‚Çã, Q‚Çã‚Çä = Q‚Çú‚Çä + A‚Çú‚ÇäQ‚Çã‚ÇúA‚Çú‚Çä·µÄ)

       p([x‚Çú, x‚Çä]| x‚Çã) = p(x‚Çä| x‚Çú)p(x‚Çú|x‚Çã)
                     = ùìù([A‚Çã‚Çúx‚Çã, A‚Çã‚Çäx‚Çã]·µÄ, [[ Q‚Çã‚Çú, Q‚Çã‚ÇúA‚Çú‚Çä·µÄ],
                                            [ A‚Çú‚ÇäQ‚Çã‚Çú, Q‚Çã‚Çä ]]

       Given this joint distribution we can obtain the mean and covariance of the
       conditional distribution of
       p(x‚Çú|[x‚Çã, x‚Çä]) = ùìù(x‚Çú; A‚Çã‚Çúx‚Çã + Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬π(x‚Çä - A‚Çã‚Çäx‚Çã), Q‚Çã‚Çú - Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πA‚Çú‚ÇäQ‚Çã‚Çú)
                      = ùìù(x‚Çú; (A‚Çã‚Çú - Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πA‚Çã‚Çä)x‚Çã + Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πx‚Çä,
                               (Q‚Çã‚Çú‚Åª¬π + A‚Çú‚Çä·µÄQ‚Çú‚Çä‚Åª¬πA‚Çú‚Çä)‚Åª¬π)

   :param state_transitions_to_t: the state transitions from t‚Çã to t - A‚Çã‚Çú
           ``batch_shape + [num_time_points, state_dim, state_dim]``
   :param process_covariances_to_t: the process covariances from t‚Çã to t - Q‚Çã‚Çú
           ``batch_shape + [num_time_points, state_dim, state_dim]``
   :param state_transitions_from_t: the state transitions from t to t‚Çä - A‚Çã‚Çú
           ``batch_shape + [num_time_points, state_dim, state_dim]``
   :param process_covariances_from_t: the process covariances from t to t‚Çä - Q‚Çú‚Çä
           ``batch_shape + [num_time_points, state_dim, state_dim]``
   :param return_precision: bool, defaults to False.
           if True (resp. False), conditional precision (resp. covariance) is returned
   :return: parameters for the conditional mean and covariance
           ``batch_shape + [num_time_points, state_dim, state_dim]``
           ``batch_shape + [num_time_points, state_dim, state_dim]``
           ``batch_shape + [num_time_points, state_dim, state_dim]``


.. py:function:: _conditional_statistics(new_time_points: tensorflow.Tensor, training_time_points: tensorflow.Tensor, kernel: markovflow.kernels.SDEKernel) -> Tuple[tensorflow.Tensor, tensorflow.Tensor, tensorflow.Tensor]

   ‚àÄ x‚Çú ‚àà new_time_points, computes the statistics P‚Çú and T‚Çú of the conditional densities:
       p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)
   where
     - p is the density over state trajectories specified by the kernel
     - ‚àÄ x‚Çú ‚àà new_time_points
            x‚Çä = arg min‚Çì { |x-x‚Çú|, x ‚àà training_time_point and x>x‚Çú }
            x‚Çã = arg min‚Çì { |x-x‚Çú|, x ‚àà training_time_point and x‚©Ωx‚Çú }

   Warning: `new_time_points` and `training_time_points` must be sorted

   :param new_time_points: sorted time points to generate observations for
           ``batch_shape + [num_new_time_points,]``
   :param training_time_points: sorted time points to condition on
           ``batch_shape + [num_training_time_points,]``
   :param kernel: a Markovian Kernel
   :return: parameters for the conditional mean and covariance, and the insertion indices
           ``batch_shape + [num_new_time_points, state_dim, 2*state_dim]``
           ``batch_shape + [num_new_time_points, state_dim, state_dim]``
           ``batch_shape + [num_new_time_points,]``


.. py:function:: cyclic_reduction_conditional_statistics(explained_time_points: tensorflow.Tensor, conditioning_time_points: tensorflow.Tensor, kernel: markovflow.kernels.SDEKernel) -> Tuple[tensorflow.Tensor, tensorflow.Tensor, tensorflow.Tensor]

   Compute :math:`F‚Çú, G‚Çú, L‚Çú`. Such that:

   .. math:: p(x·µâ‚Çú | x·∂ú‚Çú‚Çã‚ÇÅ,  x·∂ú‚Çú‚Çä‚ÇÅ) = ùìù(x·µâ‚Çú; F‚Çú @ x·∂ú‚Çú‚Çã‚ÇÅ + G‚Çú @ x·∂ú‚Çú‚Çä‚ÇÅ, T‚Çú = (L‚Çú L‚Çú·µÄ)‚Åª¬π = L‚Çú‚Åª·µÄL‚Çú‚Åª¬π)

   ...where superscripts :math:`e` and :math:`c` refer to explained and conditioning respectively.

   .. note:: :math:`x·µâ` and :math:`x·∂ú` must be sorted, such that:

       .. math:: x·µâ‚ÇÄ < x·∂ú‚ÇÄ < x·µâ‚ÇÅ < ...  < x·µâ‚Çú < x·∂ú‚Çú < x·∂ú‚Çú‚Çä‚ÇÅ < x·∂ú‚Çú‚Çä‚ÇÅ < ...

       ...where :math:`len(x·µâ) = len(x·∂ú)` or :math:`len(x·µâ) = len(x·∂ú) + 1`.

   This computes the conditional statistics :math:`F‚Çú, G‚Çú, L‚Çú`, where
   :math:`ùîº x·µâ|x·∂ú = - L‚Åª·µÄ U·µÄ x·∂ú`, with::

       U·µÄ = | F‚ÇÅ·µÄ                 [      |]  and  L‚Åª·µÄ = |L‚ÇÅ‚Åª·µÄ               |
            |  G‚ÇÅ·µÄ, F‚ÇÇ·µÄ           [      |]             |   L‚ÇÇ‚Åª·µÄ            |
            |     , G‚ÇÇ·µÄ,‚ã±         [      |]             |      L‚ÇÉ‚Åª·µÄ         |
            |           ‚ã± ‚ã±       [      |]             |        ‚ã±          |
            |             ‚ã± F‚Çô‚Çã‚ÇÅ·µÄ [      |]             |          ‚ã±        |
            |               G‚Çô‚Çã‚ÇÅ·µÄ [ F‚Çô·µÄ  |]             |            L‚Çô‚Åª·µÄ   |

   :math:`L` is the Cholesky factor of the conditional precision :math:`x·µâ|x·∂ú`.

   Statistics :math:`F` and :math:`G` are computed from the conditional mean projection
   parameters :math:`D` and :math:`E` defined by :math:`ùîº x·µâ‚Çô|x·∂ú = D‚Çô @ x·∂ú‚Çô‚Çã‚ÇÅ + E‚Çô @ x·∂ú‚Çô`.

   Solving the system :math:`- (L‚Åª·µÄ U·µÄ x·∂ú)‚Çô = D‚Çô @ x·∂ú‚Çô‚Çã‚ÇÅ + E‚Çô @ x·∂ú‚Çô`,
   we get :math:`G‚Çô‚Çã‚ÇÅ·µÄ = -L‚Çô·µÄ D‚Çô` and :math:`F‚Çô·µÄ = -L‚Çô·µÄ E‚Çô`.

   Details of the system::

       -| L‚ÇÅ‚Åª·µÄF‚ÇÅ·µÄ x·∂ú‚ÇÅ                     | = | E‚ÇÅ x·∂ú‚ÇÅ
        | L‚ÇÇ‚Åª·µÄG‚ÇÅ·µÄx·∂ú‚ÇÅ  + L‚ÇÇ‚Åª·µÄ F‚ÇÇ·µÄ x·∂ú‚ÇÇ      |   | D‚ÇÇ x·∂ú‚ÇÅ +   E‚ÇÇ x·∂ú‚ÇÇ
        | L‚ÇÉ‚Åª·µÄ G‚ÇÇ·µÄ x·∂ú‚ÇÇ , L‚ÇÉ‚Åª·µÄ F‚ÇÉ·µÄ x·∂ú‚ÇÉ,    |   | D‚ÇÉ x·∂ú‚ÇÇ +   E‚ÇÉ x·∂ú‚ÇÉ
        | ‚ãÆ                               |   | ‚ãÆ
        | L‚Çô‚Åª·µÄ G‚Çô‚Çã‚ÇÅ·µÄx·∂ú‚Çô‚Çã‚ÇÅ,   L‚Çô‚Åª·µÄ [F‚Çô·µÄ]x·∂ú‚Çô|   | D‚Çô x·∂ú‚Çô‚Çã‚ÇÅ +   [E‚Çô] x·∂ú‚Çô

   Remarks on size:

   * When splitting :math:`x` of size :math:`n` into odd and even, you get
     :math:`n·µâ = (n+1)//2` and :math:`n·∂ú = n//2`
   * At each level, cyclic reduction statistics have shape:

     .. math::
        &- F : n·∂ú\\
        &- G : n·µâ - 1\\
        &- L : n·µâ\\

   Note that:

       * :math:`F‚ÇÄ` is not defined (there is no time point below :math:`x·µâ‚ÇÄ`)
       * The last element :math:`G` may not be defined if :math:`len(x·µâ) = len(x·∂ú)`

   :param explained_time_points: Sorted time points to generate observations for, with shape
           ``batch_shape + [num_time_points_1,]``.
   :param conditioning_time_points: Sorted time points to condition on, with shape
           ``batch_shape + [num_time_points_2,]``.
   :param kernel:  A kernel.
   :return: Parameters for the conditional, with respective shapes
           ``batch_shape + [num_conditioning, state_dim, state_dim]``
           ``batch_shape + [num_explained - 1, state_dim, state_dim]``
           ``batch_shape + [num_explained, state_dim, state_dim]``.


.. py:function:: base_conditional_predict(conditional_projections: tensorflow.Tensor, conditional_covariances: tensorflow.Tensor, adjacent_states: tensorflow.Tensor, pairwise_state_covariances: Optional[tensorflow.Tensor] = None) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

   Predict state at new time points given conditional statistics.

   Given conditionals statistics :math:`P‚Çú, T‚Çú` of :math:`p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)`
   and pairwise marginals :math:`p(x‚Çú‚Çã, x‚Çú‚Çä) = ùìù(m‚Çú, S‚Çú)`,
   compute marginal mean and covariance of the marginal density:

   .. math:: p(x‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú + P‚Çú S‚Çú P‚Çú·µÄ)

   If :math:`S‚Çú` is not provided, compute the conditional mean and covariance of the
   conditional density:

   .. math:: p(x‚Çú|[x‚Çú‚Çã, x‚Çú‚Çä] = m‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú)

   :param conditional_projections: :math:`P‚Çú` with shape
           ``batch_shape + [num_time_points, state_dim]``.
   :param conditional_covariances: :math:`T‚Çú` with shape
           ``batch_shape + [num_time_points, state_dim, state_dim]``.
   :param adjacent_states: Pairs of states to condition on, with shape
           ``batch_shape + [num_time_points, 2 * state_dim]``.
   :param pairwise_state_covariances: Covariances of the pairs of states to condition on,
           with shape ``batch_shape + [num_time_points, 2 * state_dim, 2 * state_dim]``.
   :return: Predicted mean and covariance for the time points, with respective shapes
           ``batch_shape + [num_time_points, state_dim]``
           ``batch_shape + [num_time_points, state_dim, state_dim]``.


.. py:function:: pairwise_marginals(dist: markovflow.gauss_markov.GaussMarkovDistribution, initial_mean: tensorflow.Tensor, initial_covariance: tensorflow.Tensor) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

   TODO(sam): figure out what the initial mean and covariance should be for non-stationary kernels

   For each pair of subsequent states :math:`x‚Çñ, x‚Çñ‚Çä‚ÇÅ`, return the mean and covariance of
   their joint distribution. This is assuming we start from, and revert to, the prior:

   .. math::
       &p(x‚Çñ) = ùìù(Œº‚Çñ, P‚Çñ)  \verb|(we can get this from the marginals method)|\\
       &p(x‚Çñ‚Çä‚ÇÅ | x‚Çñ) = ùìù(A‚ÇñŒº‚Çñ, Q‚Çñ)

   Then:

   .. math::
       p(x‚Çñ‚Çä‚ÇÅ, x‚Çñ) = ùìù([Œº‚Çñ, Œº‚Çñ‚Çä‚ÇÅ], [P‚Çñ, P‚Çñ A‚Çñ·µÄ])\\
                                    [A‚Çñ P‚Çñ, P‚Çñ‚Çä‚ÇÅ]

   :param dist: The distribution.
   :param initial_mean:  The prior mean (used to extend the pairwise marginals
       of the distribution).
   :param initial_covariance: The prior covariance (used to extend the pairwise marginal of
       the state space model).
   :return: Mean and covariance pairs for the marginals, with respective shapes
           ``batch_shape + [num_transitions + 2, state_dim]``
           ``batch_shape + [num_transitions + 2, state_dim, state_dim]``.


