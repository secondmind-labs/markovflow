:py:mod:`markovflow.kernels.sde_kernel`
=======================================

.. py:module:: markovflow.kernels.sde_kernel

.. autoapi-nested-parse::

   Module containing Stochastic Differential Equation (SDE) kernels.



Module Contents
---------------

.. py:class:: SDEKernel(output_dim: int = 1, jitter: float = 0)

   Bases: :py:obj:`markovflow.kernels.kernel.Kernel`, :py:obj:`abc.ABC`

   Abstract class representing kernels defined by the Stochastic Differential Equation:

   .. math::
       &dx(t)/dt = F(t) x(t) + L(t) w(t),\\
       &f(t) = H(t) x(t)

   For most kernels :math:`F, L, H` are not time varying; these have the more restricted form:

   .. math::
       &dx(t)/dt = F x(t) + L w(t),\\
       &f(t) = H x(t)

   ...with :math:`w(t)` white noise process with spectral density :math:`Q_c`, where:

   .. math::
       &x âˆˆ â„^d\\
       &F, L âˆˆ â„^{d Ã— d}\\
       &H âˆˆ â„^{d Ã— o}\\
       &Q_c âˆˆ â„^d\\
       &d \verb|is the state dimension|\\
       &o \verb|is the observation dimension|

   See the documentation for the :class:`StationaryKernel` class.

   Usually:

   .. math:: x(t) = [a(t), da(t)/dt, dÂ²a(t)/dt ...]

   ...for some :math:`a(t)`, so the state dimension represents the degree of the stochastic
   differential equation in terms of :math:`a(t)`. Writing it in the above form is a standard
   trick for converting a higher order linear differential equation into a first order linear one.

   Since :math:`F, L, H` are constant matrices, the solution can be written analytically.
   For a given set of time points :math:`tâ‚–`, we can solve this SDE and define a state
   space model of the form:

   .. math:: xâ‚–â‚Šâ‚ = Aâ‚– xâ‚– + bâ‚– + qâ‚–

   ...where:

   .. math::
       &qâ‚– \sim ð“(0, Qâ‚–)\\
       &xâ‚€ \sim ð“(Î¼â‚€, Pâ‚€)\\
       &xâ‚– âˆˆ â„^d\\
       &Aâ‚– âˆˆ â„^{d Ã— d}\\
       &bâ‚– âˆˆ â„^d\\
       &Qâ‚– âˆˆ â„^{d Ã— d}\\
       &Î¼â‚€ âˆˆ â„^{d Ã— 1}\\
       &Pâ‚€ âˆˆ â„^{d Ã— d}

   If :math:`Î”tâ‚– = tâ‚–â‚Šâ‚ - tâ‚–`, then the transition matrix :math:`Aâ‚œ` between states
   :math:`x(tâ‚–)` and :math:`x(tâ‚–â‚Šâ‚)` is given by:

   .. math:: Aâ‚– = exp(FÎ”tâ‚–)

   The process noise covariance matrix :math:`Qâ‚–` between states :math:`x(tâ‚–)` and
   :math:`x(tâ‚–â‚Šâ‚)` is given by:

   .. math:: Qâ‚– = âˆ« exp(F (Î”tâ‚– - Ï„)) L Q_c Láµ€ exp(F (Î”tâ‚– - Ï„))áµ€ dÏ„

   We can write this in terms of the steady state covariance :math:`Pâˆž` as:

   .. math:: Qâ‚– = Pâˆž - Aâ‚– Pâˆž Aâ‚–áµ€

   We also define an emission model for a given output dimension:

   .. math:: fâ‚– = H xâ‚–

   ...where:

   .. math::
       &x âˆˆ â„^d\\
       &f âˆˆ â„^m\\
       &H âˆˆ â„^{m Ã— d}\\
       &m \verb| is the output_dim|

   :param output_dim: The output dimension of the kernel.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
       maintain numerical stability during inversion.

   .. py:method:: output_dim() -> int
      :property:

      Return the output dimension of the kernel.


   .. py:method:: build_finite_distribution(time_points: tensorflow.Tensor) -> markovflow.gauss_markov.GaussMarkovDistribution

      Return the :class:`~markovflow.gauss_markov.GaussMarkovDistribution` that this kernel
      represents on the provided time points.

      .. note:: Currently the only representation we can use is
          :class:`~markovflow.state_space_model.StateSpaceModel`.

      :param time_points: The times between which to define the distribution, with
          shape ``batch_shape + [num_data]``.


   .. py:method:: state_space_model(time_points: tensorflow.Tensor) -> markovflow.state_space_model.StateSpaceModel

      Return the :class:`~markovflow.state_space_model.StateSpaceModel` that this
      kernel represents on the provided time points.

      :param time_points: The times between which to define the state space model, with shape
          ``batch_shape + [num_data]``. This must be strictly increasing.


   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the :class:`~markovflow.emission_model.EmissionModel` associated with this kernel
      that maps from the latent :class:`~markovflow.state_space_model.StateSpaceModel`
      to the observations.

      For any :class:`SDEKernel`, the state representation is usually:

      .. math:: x(t) = [a(t), da(t)/dt, dÂ²a(t)/dt ...] \verb| for some | a(t)

      In this case, we are interested only in the first element of :math:`x`. That is, the
      output :math:`f(t)` is given by :math:`f(t) = a(t)`, so :math:`H` is given by
      :math:`[1, 0, 0, ...]`.

      If different behaviour is required, this method should be overridden.

      :param time_points: The time points over which the emission model is defined, with shape
          ``batch_shape + [num_data]``.


   .. py:method:: initial_mean(batch_shape: tensorflow.TensorShape) -> tensorflow.Tensor

      Return the initial mean of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.

      :param batch_shape: Leading dimensions for the initial mean.
      :return: A tensor of zeros with shape ``batch_shape + [state_dim]``.


   .. py:method:: state_dim() -> int
      :property:

      Return the state dimension of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.


   .. py:method:: initial_covariance(initial_time_point: tensorflow.Tensor) -> tensorflow.Tensor
      :abstractmethod:

      Return the initial covariance of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      For stationary kernels this is typically the covariance of the stationary distribution for
      :math:`x, Pâˆž`.

      In the general case the initial covariance depends on time, so we  need the
      `initial_time_point` to generate it.

      :param initial_time_point: The time_point associated with the first state, with shape
          ``batch_shape + [1,]``.
      :return: A tensor with shape ``batch_shape + [state_dim, state_dim]``.


   .. py:method:: transition_statistics_from_time_points(time_points: tensorflow.Tensor)

      Generate the transition matrices when the time deltas are
      between adjacent `time_points`.

      :param time_points: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions + 1]``.
      :return: A tuple of two tensors, with respective shapes
          ``batch_shape + [num_transitions, state_dim, state_dim]``
          ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: transition_statistics(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]
      :abstractmethod:

      Return the :meth:`state_transitions` and :meth:`process_covariances` together to
      save having to compute them twice.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tuple of two tensors, with respective shapes
          ``batch_shape + [num_transitions, state_dim, state_dim]``.
          ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: state_offsets(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor
      :abstractmethod:

      Return the state offsets :math:`bâ‚–` of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim]``.


   .. py:method:: state_transitions(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor
      :abstractmethod:

      Return the state transition matrices of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel` :math:`Aâ‚– = exp(FÎ”tâ‚–)`.

      :param transition_times: Time points at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: Time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: process_covariances(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the process covariance matrices of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      The process covariance at time :math:`k` is calculated as:

      .. math:: Qâ‚– = Pâˆž - Aâ‚– Pâˆž Aâ‚–áµ€

      These transition matrices can be overridden for more specific use cases if necessary.

      :param transition_times: Time points at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: Time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: jitter_matrix() -> tensorflow.Tensor
      :property:

      Jitter to add to the output of :meth:`process_covariances` and
      :meth:`initial_covariance` shape.

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: __add__(other: SDEKernel) -> Sum

      Operator for combining kernel objects by summing them. 


   .. py:method:: __mul__(other: SDEKernel) -> Product

      Operator for combining kernel objects by multiplying them. 



.. py:class:: StationaryKernel(output_dim: int = 1, jitter: float = 0, state_mean: Optional[tensorflow.Tensor] = None, **kwargs)

   Bases: :py:obj:`SDEKernel`, :py:obj:`abc.ABC`

   Abstract class representing stationary kernels defined by the Stochastic Differential Equation:

   .. math::
       &dx(t)/dt = F x(t) + L w(t),\\
       &f(t) = H(t) x(t)

   For most kernels :math:`H` will not be time varying; that is, :math:`f(t) = H x(t)`.

   :param output_dim: The output dimension of the kernel.
   :param state_mean: A tensor with shape [state_dim,].

   .. py:method:: initial_mean(batch_shape: tensorflow.TensorShape) -> tensorflow.Tensor

      Return the initial mean of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.

      :param batch_shape: Leading dimensions for the initial mean.
      :return: A tensor of zeros with shape ``batch_shape + [state_dim]``.


   .. py:method:: set_state_mean(state_mean: tensorflow.Tensor, trainable: bool = False)

      Sets the state mean for the kernel.

      :param state_mean: A tensor with shape [state_dim,].
      :param trainable: Boolean value to set the state mean trainable.


   .. py:method:: initial_covariance(initial_time_point: tensorflow.Tensor) -> tensorflow.Tensor

      Return the initial covariance of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      For stationary kernels this is the covariance of the stationary distribution for
      :math:`x,Pâˆž` and is independent of the time passed in.

      :param initial_time_point: The time point associated with the first state, with shape
          ``batch_shape + [1,]``.
      :return: A tensor with shape ``batch_shape + [state_dim, state_dim]``.


   .. py:method:: transition_statistics(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

      Return :meth:`state_transitions` and :meth:`process_covariances` together to save
      having to compute them twice.

      By default this uses the state transitions to calculate the process covariance:

      .. math:: Qâ‚– = Pâˆž - Aâ‚– Pâˆž Aâ‚–áµ€

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tuple of two tensors, with respective shapes
          ``batch_shape + [num_transitions, state_dim, state_dim]``.
          ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: feedback_matrix() -> tensorflow.Tensor
      :property:

      Return the feedback matrix :math:`F`. This is where:

      .. math:: dx(t)/dt = F x(t) + L w(t)

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: state_offsets(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      :math:`dx = F (x - m)dt         o  x(t) = A x(0) + (I-A)m`

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim]``


   .. py:method:: steady_state_covariance() -> tensorflow.Tensor
      :property:

      Return the steady state covariance :math:`Pâˆž`, given implicitly by:

      .. math:: F Pâˆž + Pâˆž Fáµ€ + LQ_cLáµ€ = 0

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: state_mean() -> tensorflow.Tensor
      :property:

      Return the state mean.

      :return: A tensor with shape ``[state_dim,]``.



.. py:class:: NonStationaryKernel(output_dim: int = 1, jitter: float = 0)

   Bases: :py:obj:`SDEKernel`, :py:obj:`abc.ABC`

   Abstract class representing non-stationary kernels defined by the Stochastic Differential
   Equation:

   .. math::
       &dx(t)/dt = F(t) x(t) + L(t) w(t),\\
       &f(t) = H(t) x(t)

   For most kernels :math:`H` will not be time varying; that is, :math:`f(t) = H x(t)`.

   :param output_dim: The output dimension of the kernel.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
       maintain numerical stability during inversion.

   .. py:method:: feedback_matrices(time_points: tensorflow.Tensor) -> tensorflow.Tensor
      :abstractmethod:

      The non-stationary feedback matrix :math:`F(t)` at times :math:`t`, where:

      .. math:: dx(t)/dt = F(t) x(t) + L w(t)

      :param time_points: The times at which the feedback matrix is evaluated, with shape
          ``batch_shape + [num_time_points]``.
      :return: A tensor with shape ``batch_shape + [num_time_points, state_dim, state_dim]``.


   .. py:method:: state_offsets(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor
      :abstractmethod:

      Return the state offsets :math:`bâ‚–` of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.
      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim]``



.. py:class:: ConcatKernel(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`StationaryKernel`, :py:obj:`abc.ABC`

   Abstract class implementing the state space model of multiple kernels that have been
   combined together. Combined with differing emission models this can give rise to the
   :class:`Sum` kernel or to a multi-output kernel.

   The state space of any :class:`ConcatKernel` consists of all the state spaces of
   child kernels concatenated (in the tensorflow.concat sense) together:

   .. math::
      [xÂ¹(t),\\
      xÂ²(t)]

   So the SDE of the kernel becomes:

   .. math::
       &dx(t)/dt = &[[FÂ¹ 0],     &[xÂ¹(t)    &[[LÂ¹ 0],   &[wÂ¹(t),\\
       &           &[0  FÂ²]]     &xÂ²(t)]  + &[0  LÂ²]]   &wÂ²(t)]\\
       &f(t) = [HÂ¹ HÂ²] x(t)

   :param kernels: A list of child kernels that will have their state spaces
                   concatenated together.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
                  maintain numerical stability during inversion.

   .. py:method:: state_dim() -> int
      :property:

      Return the state dimension of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.


   .. py:method:: kernels() -> List[SDEKernel]
      :property:

      Return a list of child kernels.


   .. py:method:: state_transitions(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state transition matrices of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel` :math:`Aâ‚– = exp(FÎ”tâ‚–)`.

      The state transition matrix is the block diagonal matrix of the child state
      transition matrices.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: initial_mean(batch_shape: tensorflow.TensorShape) -> tensorflow.Tensor

      Return the initial mean of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      The combined mean is the child means concatenated together:

      .. math:: [Î¼1 Î¼2, ...]

      ...to form a longer mean vector.

      :param batch_shape: A tuple of leading dimensions for the initial mean.
      :return: A tensor of zeros with shape ``batch_shape + [state_dim]``.


   .. py:method:: feedback_matrix() -> tensorflow.Tensor
      :property:

      Return the feedback matrix. This is the block diagonal matrix of
      child feedback matrices.

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: steady_state_covariance() -> tensorflow.Tensor
      :property:

      Return the steady state covariance. This is the block diagonal matrix of
      child steady state covariance matrices.

      :return: A tensor with shape ``[state_dim, state_dim]``.



.. py:class:: Sum(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`ConcatKernel`

   Sums a list of child kernels.

   There are two ways to implement this kernel: Stacked and Concatenated.

   This class implements the Concatenated version, where the state space of the :class:`Sum`
   kernel includes covariance terms between the child kernels.

   :param kernels: A list of child kernels that will have their state spaces
                   concatenated together.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
                  maintain numerical stability during inversion.

   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the emission matrix :math:`H`. This is the concatenation:

      .. math:: H = [Hâ‚, Hâ‚‚, ..., Hâ‚™]

      ...where :math:`\{Háµ¢\}â‚™` are the emission matrices of the child kernels. Thus the state
      dimension for this kernel is the sum of the state dimension of the child kernels.

      :param time_points: The time points over which the emission model is defined, with shape
                      ``batch_shape + [num_data]``.
      :return: The emission model associated with this kernel, with emission matrix with shape
                      ``batch_shape + [num_data, output_dim, state_dim]``.



.. py:class:: Product(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`StationaryKernel`

   Multiplies a list of child kernels.

   The feedback matrix is the Kronecker product of the feedback matrices from the child kernels.
   We will use a product kernel with two child kernels as an example. Let :math:`A` and
   :math:`B` be the feedback matrix from these two child kernels. The feedback matrix :math:`F`
   of the product kernel is:

   .. math::
       &F &= &A âŠ— B\\
       &  &= &[[Aâ‚â‚ B, ..., Aâ‚â‚™ B],\\
       &  &  &...,\\
       &  &  &[Aâ‚™â‚ B, ..., Aâ‚™â‚™ B]]

   ...where :math:`âŠ—` is the Kronecker product operator.

   The state transition matrix is the Kronecker product of the state transition matrices from
   the child kernels. Let :math:`Aâ‚–` and :math:`Bâ‚–` be the state transition matrix from these two
   child kernels at time step :math:`k`. The state transition matrix
   :math:`Sâ‚–` of the product kernel is:

   .. math::
       &Sâ‚– &= &Aâ‚– âŠ— Bâ‚–\\
       &   &= &[[Aâ‚–â‚â‚ Bâ‚–, ..., Aâ‚–â‚â‚™ Bâ‚–],\\
       &   &  &...,\\
       &   &  &[Aâ‚–â‚™â‚ Bâ‚–, ..., Aâ‚–â‚™â‚™ Bâ‚–]]

   The steady state covariance matrix is the Kronecker product of the steady covariance matrix
   from the child kernels. Let :math:`Aâˆž` and :math:`Bâˆž` be the steady covariance matrix from
   these two child kernels. The state transition matrix :math:`Pâˆž` of the product kernel is:

   .. math::
       &Pâˆž &= &Aâˆž âŠ— Bâˆž\\
       &   &= &[[Aâˆžâ‚â‚ Bâˆž, ..., Aâˆž Bâˆž],\\
       &   &  &...,\\
       &   &  &[Aâˆžâ‚™â‚ Bâˆž, ..., Aâˆžâ‚™â‚™ Bâˆž]]

   The process covariance matrix :math:`Qâ‚–` at time step :math:`k` is calculated using the
   same formula as defined in the parent class SDEKernel:

   .. math:: Qâ‚– = Pâˆž - Sâ‚– Pâˆž Sâ‚–áµ€

   ...where the steady state matrix :math:`Pâˆž` and the state transition :math:`Sâ‚–`
   are defined above.

   :param kernels: An iterable over the kernels to be multiplied together.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
       maintain numerical stability during inversion.

   .. py:method:: state_dim() -> int
      :property:

      Return the state dimension of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.


   .. py:method:: kernels() -> List[SDEKernel]
      :property:

      Return a list of child kernels.


   .. py:method:: state_transitions(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state transition. This is the Kronecker product of the child state transitions.

      :param transition_times: A tensor of times at which to produce matrices, shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: feedback_matrix() -> tensorflow.Tensor
      :property:

      Return the feedback matrix. This is the Kronecker product of the child feedback matrices.

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: steady_state_covariance() -> tensorflow.Tensor
      :property:

      Return the steady state covariance. This is the Kronecker product
      of the child steady state covariances.

      :return: A tensor with shape ``[state_dim, state_dim]``.


   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the emission matrix. This is the
      Kronecker product of all the child emission matrices.

      :param time_points: The time points over which the emission model is defined, with shape
          ``batch_shape + [num_data]``.



.. py:class:: IndependentMultiOutput(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`ConcatKernel`

   Takes a concatenated state space model consisting of multiple child
   kernels and projects the state space associated with each kernel into a separate observation
   vector.

   The result is similar to training several kernels on the same data separately,
   except that because of the covariance terms in the state space there can be correlation
   between the separate observation vectors.

   :param kernels: An iterable over child kernels which will have their state spaces
                   concatenated together.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
                  maintain numerical stability during inversion.

   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the emission matrix :math:`H`. This is the direct sum of the child emission
      matrices, for example:

      .. math:: H = Hâ‚ âŠ• Hâ‚‚ âŠ• ... âŠ• Hâ‚™

      ...where :math:`\{Háµ¢\}â‚™` are the emission matrices of the child kernels.

      :param time_points: The time points over which the emission model is defined, with shape
                      ``batch_shape + [num_data]``.
      :return: The emission model associated with this kernel.



.. py:class:: FactorAnalysisKernel(weight_function: Callable[[gpflow.base.TensorType], gpflow.base.TensorType], kernels: List[SDEKernel], output_dim: int, trainable: bool = True, jitter: float = 0.0)

   Bases: :py:obj:`ConcatKernel`

   Produces an emission model which performs a linear mixing of Gaussian
   processes according to a known time varying weight function and a learnable loading matrix:

   .. math:: fáµ¢(t) = Î£â±¼â‚– Aáµ¢â±¼(t)Bâ±¼â‚–gâ‚–(t)

   ...where:

       * :math:`\{fáµ¢\}â‚™` are the observable processes
       * :math:`\{gâ‚–\}â‚˜` are the latent GPs
       * :math:`A^{n Ã— m}` is a known, possibly time dependant, weight matrix
       * :math:`B^{m Ã— m}` is either the identity or a trainable loading matrix

   :param weight_function: A function that, given :data:`~markovflow.base.TensorType`
       time points with shape ``batch_shape + [num_data, ]``, returns a weight matrix
       with the relative mixing of the tensors, with shape
       ``batch_shape + [num_data, output_dim, n_latents]``.
   :param kernels: An iterable over child kernels that will have their state spaces
           concatenated together, with shape ``[n_latents, ]``.
   :param output_dim: The output dimension of the kernel. This should have the same shape as
           the `output_dim` of the weight matrix returned by the weight function.
   :param trainable: Whether the loading matrix :math:`B` should be trainable.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
                  maintain numerical stability during inversion.

   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the emission matrix :math:`WH`. This is where:

      .. math:: H = Hâ‚ âŠ• Hâ‚‚ âŠ• ... âŠ• Hâ‚™

      ...as per the multi-output kernel, and :math:`W = AB`.

      :param time_points: The time points over which the emission model is defined, with shape
                      ``batch_shape + [num_data, ]``.
      :return: The emission model associated with this kernel.



.. py:class:: StackKernel(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`StationaryKernel`

   Implements the state space model of multiple kernels that have been combined together.
   Unlike a :class:`ConcatKernel`, it manages the multiple
   kernels by introducing a leading dimension (stacking), rather than forming a block
   diagonal form of each parameter explicitly.

   The prior of both a :class:`StackKernel` and a :class:`ConcatKernel` is the same (independent).
   However, posterior state space models built upon a :class:`StackKernel` will maintain this
   independency, in contrast to the posteriors building upon a :class:`ConcatKernel`,
   which model correlations between the processes.

   Combined with different emission models this can give rise to a multi-output stack
   kernel, and perhaps in the future an additive kernel.

   The state space of this kernel consists of all the state space of the child kernels
   stacked (in the tensorflow.stack sense) together, with padded zeros when the state space
   of one of the kernels is larger than any of the others::

       [ xâ‚â½Â¹â¾(t) ] á¨ž
       [   0   ]   [ xâ‚â½áµâ¾(t) ]
                 á¨ž [ xâ‚‚â½áµâ¾(t) ]

   ...where :math:`m` are the number of kernels / outputs.

   So the SDE of the kernel becomes::

       dx(t)/dt = [Fâ½Â¹â¾] á¨ž   [xâ½Â¹â¾(t)] á¨ž    + [Lâ½Â¹â¾] á¨ž    [wâ½Â¹â¾(t)] á¨ž
                     á¨ž [Fâ½áµâ¾]   á¨ž [xâ½áµâ¾(t)]      á¨ž [Lâ½áµâ¾]    á¨ž [wâ½áµâ¾(t)]

       f(t) = [Hâ½Â¹â¾] á¨ž   [xâ½Â¹â¾(t)] á¨ž
                 á¨ž [Hâ½áµâ¾]   á¨ž [xâ½áµâ¾(t)]

   :param kernels: A list of child kernels that will have their state spaces
       concatenated together. Since we model each output independently, the length of the
       kernel list defines the number of the outputs. Note that each kernel should have
       individual `output_dim` 1.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
                  maintain numerical stability during inversion.

   .. py:method:: state_dim() -> int
      :property:

      Return the state dimension of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.


   .. py:method:: kernels() -> List[SDEKernel]
      :property:

      Return a list of child kernels.


   .. py:method:: _check_batch_shape_is_compatible(batch_shape: tensorflow.TensorShape) -> None

      Helper method to check the compatibility of batch_shape.
      For the `StackKernel` the batch_shape must have the following shape:

                  (..., num_kernels)

      In any other case this method raises a tf.errors.InvalidArgumentError.

      :param batch_shape: a tuple with the shape to check


   .. py:method:: state_transitions(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state transition matrices of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel` :math:`Aâ‚– = exp(FÎ”tâ‚–)`.

      The state transition matrix is the stacked matrix of the child state
      transition matrices, padded with zeros (if necessary) to match the largest state dim
      across kernels.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]`` where ``batch_shape = (..., num_kernels)``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``
          where ``batch_shape = (..., num_kernels)``.


   .. py:method:: initial_mean(batch_shape: tensorflow.TensorShape) -> tensorflow.Tensor

      Return the initial mean of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.

      We override :meth:`SDEKernel.initial_mean` from the
      parent class to check there is a compatible `batch_shape`.

      :param batch_shape: A tuple of leading dimensions for the initial mean, where batch_shape
          can be ``(..., num_kernels)``.
      :return: A tensor of zeros with shape ``batch_shape + [state_dim]``, where
          ``batch_shape = (..., num_kernels)``.


   .. py:method:: state_offsets(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state offsets :math:`bâ‚–` of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.

      We override :meth:`SDEKernel.state_offsets` from the
      parent class to check there is a compatible `batch_shape`.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim]``


   .. py:method:: feedback_matrix() -> tensorflow.Tensor
      :property:

      Return the feedback matrix. This is the stacked matrix of child feedback matrices, padded
      with zeros to have matching state dims.

      :return: A tensor with shape ``[num_kernels, state_dim, state_dim]``.


   .. py:method:: steady_state_covariance() -> tensorflow.Tensor
      :property:

      Return the steady state covariance. This is the stacked matrix of child steady state
      covariance matrices, padded with the identity (if necessary) to have matching state dims.

      Note that we further append a singleton dimensions after the `num_kernels` so it
      can broadcast across the number of data.

      :return: A tensor with shape ``[num_kernels, 1, state_dim, state_dim]``.


   .. py:method:: initial_covariance(initial_time_point: tensorflow.Tensor) -> tensorflow.Tensor

      Return the initial covariance of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This is typically the covariance of the stationary distribution for :math:`x, Pâˆž`.

      We override :meth:`SDEKernel.initial_covariance` from the
      parent class to check there is a compatible `batch_shape`.

      :param initial_time_point: The time point associated with the first state, shape
          ``batch_shape + [1,]``.
      :return: A tensor with shape ``batch_shape + [state_dim, state_dim]``,
          where ``batch_shape = (..., num_kernels)``.



.. py:class:: IndependentMultiOutputStack(kernels: List[SDEKernel], jitter: float = 0.0)

   Bases: :py:obj:`StackKernel`

   Takes a stacked state space model consisting of multiple child kernels and projects the
   state space associated with each kernel into a separate observation vector.

   The result is similar to training several kernels on the same data separately.
   There will be no correlations between the processes, in the prior or the posterior.

   :param kernels: An iterable over child kernels which will have their state spaces
       concatenated together. Since we model each output independently the length of the
       kernel list defines the number of the outputs.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
       maintain numerical stability during inversion.

   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the emission matrix :math:`H`. This is a stacking of the child emission matrices,
      which are first augmented (if necessary) so that they have the same state_dim.

      :param time_points: The time points over which the emission model is defined, with shape
          ``batch_shape + [num_data]`` where ``batch_shape = (..., num_kernels)``.
      :return: The emission model associated with this kernel.


   .. py:method:: __add__(other: IndependentMultiOutputStack) -> IndependentMultiOutputStack

      Operator for combining kernel objects by summing them.

      Overrides the base class :meth:`SDEKernel.__add__` method.


   .. py:method:: __mul__(other: IndependentMultiOutputStack) -> IndependentMultiOutputStack

      Operator for combining kernel objects by multiplying them.

      Overrides the base class :meth:`SDEKernel.__mul__` method.



