:py:mod:`markovflow.kernels.piecewise_stationary`
=================================================

.. py:module:: markovflow.kernels.piecewise_stationary

.. autoapi-nested-parse::

   Module containing a piecewise stationary kernel.



Module Contents
---------------

.. py:class:: PiecewiseKernel(kernels: List[markovflow.kernels.sde_kernel.StationaryKernel], change_points: gpflow.base.TensorType, output_dim: int = 1, jitter: float = 0.0)

   Bases: :py:obj:`markovflow.kernels.sde_kernel.NonStationaryKernel`

   Construct an SDE kernel whose state dynamic is governed by different SDEs. These are on the
   :math:`K+1` intervals specified by the :math:`K` change points :math:`cₖ`.

   On interval :math:`[cₖ, cₖ₊₁]`, the dynamics are governed by a SDE kernel :math:`kₖ`
   where :math:`c₀ = -∞`:

   .. math::
       &dx(t)/dt = Fₖ x(t) + Lₖ w(t),\\
       &f(t) = Hₖ x(t)

   Note the following:

       * This is currently restricted to cases where the kernels are the same.
       * State space models constructed by marginalizing out the process to
         time points :math:`t` are only valid if no transitions cross a change point.


   :param kernels: An iterable over the kernels forming this kernel.
   :param change_points: Sorted change points.
   :param output_dim: The output dimension of the kernel.
   :param jitter: A small non-negative number to add into a matrix's diagonal to
       maintain numerical stability during inversion.

   .. py:method:: state_dim() -> int
      :property:

      Return the state dimension of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.


   .. py:method:: generate_emission_model(time_points: tensorflow.Tensor) -> markovflow.emission_model.EmissionModel

      Generate the :class:`~markovflow.emission_model.EmissionModel` associated with this kernel
      that maps from the latent :class:`~markovflow.state_space_model.StateSpaceModel`
      to the observations.

      The emission matrix is the Kronecker product of all the children emission matrices.

      :param time_points: The time points over which the emission model is defined, with shape
          ``batch_shape + [num_data]``.


   .. py:method:: initial_covariance(initial_time_point: tensorflow.Tensor) -> tensorflow.Tensor

      Return the initial covariance of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This is the covariance of the stationary distribution :math:`P∞` for the kernel active at
      the time passed in.

      :param initial_time_point: The time point associated with the first state, with shape
          ``batch_shape + [1,]``.
      :return: A tensor with shape ``batch_shape + [state_dim, state_dim]``.


   .. py:method:: split_time_indices(time_points: tensorflow.Tensor) -> tensorflow.Tensor

      Gives each time point an index that refers to which interval it resides in.

      The sub-kernel that governs the SDE is different on different sub intervals,
      as specified by the change points.

      If there are :math:`K` change points, then :math:`0` is the index before the first
      change point and :math:`K + 1` is the index after the last change point.

      :param time_points: A tensor with shape ``batch_shape + [num_time_points]``.
      :return: A tensor of indices in range 0 - `num_change_points`, with shape
          ``batch_shape + [num_time_points]``.


   .. py:method:: split_input(input_tensor: tensorflow.Tensor, indices: tensorflow.Tensor) -> List[tensorflow.Tensor]

      Partitions `input_tensor` into regions determined by the change points.

      If there are :math:`K` change points, then :math:`0` is the index before the first
      change point and :math:`K + 1` is the index after the last change point.

      :param input_tensor: An arbitrary input tensor, with shape ``batch_shape + [N]``.
      :param indices: The index for each input of the input tensor,
          with shape ``batch_shape + [N]``.
      :return: A list of tensors each with shape ``batch_shape + [Nₖ]``,
          where :math:`(Σₖ Nₖ = N)`.


   .. py:method:: steady_state_covariances(time_points: tensorflow.Tensor) -> tensorflow.Tensor

      For each time point, return the steady state covariance of the kernel active for that
      time point.

      :param time_points: A tensor with shape ``batch_shape + [num_time_points]``.
      :return: The steady state covariance at each time point, with shape
          ``batch_shape + [num_time_points, state_dim, state_dim]``.


   .. py:method:: state_transitions(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state transition matrices of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel` :math:`Aₖ = exp(FΔtₖ)`.

      .. note:: Transitions are only valid if they do not cross a change point.

      :param transition_times: Time points at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: Time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: transition_statistics(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

      Return :meth:`state_transitions` and :meth:`process_covariances` together to
      save having to compute them twice.

      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tuple of two tensors, with respective shapes
          ``batch_shape + [num_transitions, state_dim, state_dim]``.
          ``batch_shape + [num_transitions, state_dim, state_dim]``.


   .. py:method:: feedback_matrices(time_points: tensorflow.Tensor) -> tensorflow.Tensor

      For each time point, return the non-stationary feedback matrix :math:`F(t)`
      of the kernel active for that time point.

      :param time_points: A tensor with shape ``batch_shape + [num_time_points]``.
      :return: The feedback matrix at each time point, with shape
          ``batch_shape + [num_time_points, state_dim, state_dim]``.


   .. py:method:: state_offsets(transition_times: tensorflow.Tensor, time_deltas: tensorflow.Tensor) -> tensorflow.Tensor

      Return the state offsets :math:`bₖ` of the generated
      :class:`~markovflow.state_space_model.StateSpaceModel`.

      This will usually be zero, but can be overridden if necessary.
      :param transition_times: A tensor of times at which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :param time_deltas: A tensor of time gaps for which to produce matrices, with shape
          ``batch_shape + [num_transitions]``.
      :return: A tensor with shape ``batch_shape + [num_transitions, state_dim]``


   .. py:method:: state_means(time_points: tensorflow.Tensor) -> tensorflow.Tensor

      For each time point, return the state mean of the kernel active for that
      time point.

      :param time_points: A tensor with shape ``batch_shape + [num_time_points]``.
      :return: The state mean at each time point ``batch_shape + [num_time_points, state_dim]``.



