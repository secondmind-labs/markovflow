{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5b6a376a",
   "metadata": {
    "cell_marker": "\"\"\""
   },
   "source": [
    "# Basic classification using the SparseCVIGaussianProcess model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a2b4d47",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "This notebook explains how to perform GP inference using the Markovflow CVIGaussianProcess model.\n",
    "Here, we perform binary classification with time as the input.\n",
    "\n",
    "As with GPR, the observations do not have to be regularly spaced. However, they do need to be sequential. We denote the input/output tuples as $(x_i, y_i)_{1 \\leq i \\leq n}$, where $x_i$ is a scalar value and $y_i \\in \\{0, 1\\}$.\n",
    "\n",
    "Our probabilistic model for this data is:\n",
    "$$\n",
    "\\begin{align}\n",
    "f \\sim \\mathcal{GP}(0, k(., .)) \\\\\n",
    "y_i \\sim \\mathcal{B}(\\Phi(f(x_i)))\n",
    "\\end{align}\n",
    "$$\n",
    "\n",
    "where $\\Phi$ is a function that maps $f(x_i)$ to $[0, 1]$, the probability that $y_i=1$. In practice, we choose $\\Phi$ to be the standard normal cumulative distribution function (also known as the probit function) which maps to $[0, 1]$.\n",
    "\n",
    "**NOTE:** If you have difficulty running this notebook, consider clearing the output and then restarting the kernel."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6cfd779",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Setup\n",
    "\n",
    "import warnings\n",
    "\n",
    "# Turn off warnings\n",
    "warnings.simplefilter('ignore')\n",
    "\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "\n",
    "from gpflow import default_float\n",
    "from gpflow.ci_utils import ci_niter\n",
    "from gpflow.likelihoods import Bernoulli\n",
    "\n",
    "from markovflow.models.sparse_variational_cvi import SparseCVIGaussianProcess\n",
    "from markovflow.kernels import Matern52\n",
    "\n",
    "\n",
    "np.random.seed(0)\n",
    "FLOAT_TYPE = default_float()\n",
    "\n",
    "# uncomment in notebook\n",
    "# try:\n",
    "#     from IPython import get_ipython\n",
    "#     get_ipython().run_line_magic('matplotlib', 'inline')\n",
    "# except AttributeError:\n",
    "#     print('Magic function can only be used in IPython environment')\n",
    "#     matplotlib.use('Agg')\n",
    "\n",
    "plt.rcParams[\"figure.figsize\"] = [15, 8]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da0a7af1",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "## Step 1: Generate training data\n",
    "\n",
    "First, let's generate some binary data $X = (x_1, \\dots, x_n)$ and $Y = (y_1, \\dots, y_n)^T$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "623e8683",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "# Generate some observations\n",
    "num_data  = 300\n",
    "num_inducing = 30\n",
    "\n",
    "time_points = np.linspace(0 , 1, num_data)\n",
    "inducing_points = np.linspace(0 , 1, num_inducing)\n",
    "F = np.cos(time_points * 20).reshape(-1, 1)\n",
    "observations = (F + np.random.randn(*F.shape) > 0).astype(float)\n",
    "data = (time_points, observations)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd553e31",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "## Step 2: Choose a kernel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bcaa461e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "kernel = Matern52(lengthscale=.2, variance=5.0)\n",
    "\n",
    "# We see Matern12 has only two dimensions (therefore there is less risk of overparameterising)\n",
    "print(kernel.state_dim)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2aa647cb",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "## Step 3: Build and optimise a model\n",
    "\n",
    "This is a classification problem with outputs between `[0,1]`, so we create a variational GP model using a Bernoulli likelihood."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25b8064d",
   "metadata": {
    "lines_to_next_cell": 3
   },
   "outputs": [],
   "source": [
    "\n",
    "# Create a likelihood object\n",
    "likelihood = Bernoulli()\n",
    "\n",
    "scvi = SparseCVIGaussianProcess(kernel=kernel,\n",
    "                          inducing_points=tf.constant(inducing_points),\n",
    "                          likelihood=likelihood,\n",
    "                          learning_rate=.1)\n",
    "\n",
    "\n",
    "def plot_model(model):\n",
    "\n",
    "    f_mu, f_var = model.posterior.predict_f(time_points)\n",
    "    f_mu = f_mu.numpy()\n",
    "    f_std = np.sqrt(f_var)\n",
    "\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    plt.vlines(inducing_points,\n",
    "               ymin=observations.min(), ymax=observations.max(),\n",
    "               color='r', label='inducing points')\n",
    "    plt.plot(time_points, observations, 'kx', ms=8, mew=2, label='data')\n",
    "    plt.plot(time_points, F, 'b', ms=8, mew=2, label='underlying $f$')\n",
    "    plt.plot(time_points, f_mu, 'C0', ms=8, mew=2, label='posterior prediction')\n",
    "    plt.fill_between(\n",
    "        time_points,\n",
    "        y1 = (f_mu - 2 * f_std).reshape(-1,),\n",
    "        y2 = (f_mu + 2 * f_std).reshape(-1,),\n",
    "        alpha=.2, facecolor='C0'\n",
    "    )\n",
    "    plt.xlabel(\"Time\")\n",
    "    plt.ylabel(\"Label\")\n",
    "    plt.legend()\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "plot_model(scvi)\n",
    "\n",
    "max_iter = ci_niter(400)\n",
    "for i in range(max_iter):\n",
    "    if i % 20 == 0:\n",
    "        print(i, scvi.classic_elbo(data))\n",
    "    scvi.update_sites(data)\n",
    "plot_model(scvi)"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_markers": "\"\"\"",
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py:percent"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
