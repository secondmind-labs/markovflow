
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>markovflow.conditionals &#8212; markovflow 0.1.0 documentation</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pydata-custom.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../index.html">
    
      <img src="../../_static/logo.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../index.html">Markovflow</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../tutorials.html">Tutorials</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../autoapi/markovflow/index.html">API Reference</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/secondmind-labs/markovflow" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for markovflow.conditionals</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (c) 2021 The Markovflow Contributors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Module for evaluating conditional distributions.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">gpflow</span> <span class="kn">import</span> <span class="n">default_float</span>

<span class="kn">from</span> <span class="nn">markovflow.base</span> <span class="kn">import</span> <span class="n">APPROX_INF</span>
<span class="kn">from</span> <span class="nn">markovflow.gauss_markov</span> <span class="kn">import</span> <span class="n">GaussMarkovDistribution</span>
<span class="kn">from</span> <span class="nn">markovflow.kernels</span> <span class="kn">import</span> <span class="n">SDEKernel</span>
<span class="kn">from</span> <span class="nn">markovflow.utils</span> <span class="kn">import</span> <span class="n">tf_scope_fn_decorator</span>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="conditional_predict"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals.conditional_predict">[docs]</a><span class="k">def</span> <span class="nf">conditional_predict</span><span class="p">(</span>
    <span class="n">new_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">training_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">SDEKernel</span><span class="p">,</span>
    <span class="n">training_pairwise_means</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">training_pairwise_covariances</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given :math:`‚àÄ x‚Çú ‚àà` `new_time_points`, compute the means and</span>
<span class="sd">    covariances of the marginal densities:</span>

<span class="sd">    .. math:: p(x‚Çú) = ‚à´ d[x‚Çã, x‚Çä] p(x‚Çú|x‚Çã, x‚Çä) q(x‚Çã, x‚Çä; m‚Çú, S‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú + P‚Çú S‚Çú P‚Çú·µÄ)</span>

<span class="sd">    Or, if :math:`S‚Çú` is not given, compute the conditional density:</span>

<span class="sd">    .. math:: p(x‚Çú|[x‚Çã, x‚Çä] = m‚Çú) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)</span>

<span class="sd">    .. note:: `new_time_points` and `training_time_points` must be sorted.</span>

<span class="sd">    Where:</span>

<span class="sd">      - :math:`p` is the density over state trajectories specified by the kernel</span>
<span class="sd">      - :math:`‚àÄ x‚Çú ‚àà` `new_time_points`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            x‚Çä = arg min‚Çì \{|x-x‚Çú|, x ‚àà \verb|training_time_point and |x&gt;x‚Çú\}\\</span>
<span class="sd">            x‚Çã = arg min‚Çì \{|x-x‚Çú|, x ‚àà \verb|training_time_point and |x‚©Ωx‚Çú\}</span>

<span class="sd">    Details of the computation of :math:`P‚Çú` and :math:`T‚Çú` are found</span>
<span class="sd">    in :func:`conditional_statistics`.</span>

<span class="sd">    :param new_time_points: Sorted time points to generate observations for, with shape</span>
<span class="sd">            ``batch_shape + [num_new_time_points,]``.</span>
<span class="sd">    :param training_time_points: Sorted time points to condition on, with shape</span>
<span class="sd">            ``batch_shape + [num_training_time_points,]``.</span>
<span class="sd">    :param kernel: A kernel.</span>
<span class="sd">    :param training_pairwise_means: Pairs of states to condition on, with shape</span>
<span class="sd">            ``batch_shape + [num_training_time_points, 2 * state_dim]``.</span>
<span class="sd">    :param training_pairwise_covariances: Covariances of the pairs of states to condition on, with</span>
<span class="sd">            shape ``batch_shape + [num_training_time_points, 2 * state_dim, 2 * state_dim]``.</span>
<span class="sd">    :return: Predicted mean and covariance for the new time points, with respective shapes</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim, state_dim]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">_conditional_statistics</span><span class="p">(</span><span class="n">new_time_points</span><span class="p">,</span> <span class="n">training_time_points</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="c1"># projection and marginalization (if S‚Çú given)</span>
    <span class="n">batch_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_time_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pairwise_means</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">training_pairwise_means</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">training_pairwise_covariances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pairwise_covs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pairwise_covs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">training_pairwise_covariances</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">base_conditional_predict</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">pairwise_means</span><span class="p">,</span> <span class="n">pairwise_state_covariances</span><span class="o">=</span><span class="n">pairwise_covs</span><span class="p">)</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="conditional_statistics"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals.conditional_statistics">[docs]</a><span class="k">def</span> <span class="nf">conditional_statistics</span><span class="p">(</span>
    <span class="n">new_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">training_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">SDEKernel</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given :math:`‚àÄ x‚Çú ‚àà` `new_time_points`, compute the statistics :math:`P‚Çú` and :math:`T‚Çú`</span>
<span class="sd">    of the conditional densities:</span>

<span class="sd">    .. math:: p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)</span>

<span class="sd">    ...where:</span>

<span class="sd">        - :math:`p` is the density over state trajectories specified by the kernel</span>
<span class="sd">        - :math:`‚àÄ x‚Çú ‚àà` `new_time_points`:</span>

<span class="sd">          .. math::</span>
<span class="sd">                x‚Çä = arg min‚Çì \{ |x-x‚Çú|, x ‚àà \verb|training_time_point and |x&gt;x‚Çú \}\\</span>
<span class="sd">                x‚Çã = arg min‚Çì \{ |x-x‚Çú|, x ‚àà \verb|training_time_point and |x‚©Ωx‚Çú \}</span>

<span class="sd">    .. note:: `new_time_points` and `training_time_points` must be sorted.</span>

<span class="sd">    :param new_time_points: Sorted time points to generate observations for, with shape</span>
<span class="sd">            ``batch_shape + [num_new_time_points,]``.</span>
<span class="sd">    :param training_time_points: Sorted time points to condition on, with shape</span>
<span class="sd">            ``batch_shape + [num_training_time_points,]``.</span>
<span class="sd">    :param kernel: A kernel.</span>
<span class="sd">    :return: Parameters for the conditional mean and covariance, with respective shapes</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim, 2 * state_dim]``</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim, state_dim]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  remove the `indices` output from `_conditional_statistics`</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_conditional_statistics</span><span class="p">(</span><span class="n">new_time_points</span><span class="p">,</span> <span class="n">training_time_points</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="_conditional_statistics_from_transitions"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals._conditional_statistics_from_transitions">[docs]</a><span class="k">def</span> <span class="nf">_conditional_statistics_from_transitions</span><span class="p">(</span>
    <span class="n">state_transitions_to_t</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">process_covariances_to_t</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">state_transitions_from_t</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">process_covariances_from_t</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">return_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation details:</span>
<span class="sd">        Given consecutive time differences Œî‚ÇÅ = t - t‚Çã and Œî‚ÇÇ = t‚Çä - t</span>
<span class="sd">        of ordered triplets t‚Çã &lt; t &lt; t‚Çä, we denote their values as</span>
<span class="sd">        x‚Çã, x‚Çú, x‚Çä and their conditional distributions as</span>
<span class="sd">        p(x‚Çä | x‚Çú) = ùìù(x‚Çä; A‚Çú‚Çäx‚Çú, Q‚Çú‚Çä)    where     [A‚Çú‚Çä == A_tp, Q‚Çú‚Çä == Q_tp]</span>
<span class="sd">        p(x‚Çú | x‚Çã) = ùìù(x‚Çú; A‚Çã‚Çúx‚Çã, Q‚Çã‚Çú)    where     [A‚Çã‚Çú == A_mt, Q‚Çã‚Çú == Q_mt]</span>

<span class="sd">        This computes D‚Çú, E‚Çú, T‚Çú (or T‚Çú‚Åª¬π) such that</span>
<span class="sd">        p(x‚Çú | x‚Çã, x‚Çä) = ùìù(x‚Çú; D‚Çú @ x‚Çã + E‚Çú @ x‚Çä, T‚Çú)</span>

<span class="sd">        p(x‚Çä|x‚Çú, x‚Çã) = p(x‚Çä|x‚Çú) = ùìù(A‚Çú‚Çäx‚Çú, Q‚Çú‚Çö)</span>
<span class="sd">        p(x‚Çú|x‚Çã) = ùìù(A‚Çã‚Çúx‚Çã, Q‚Çã‚Çú)</span>
<span class="sd">        p(x‚Çä| x‚Çã) = ùìù(A‚Çã‚Çäx‚Çã, Q‚Çã‚Çä = Q‚Çú‚Çä + A‚Çú‚ÇäQ‚Çã‚ÇúA‚Çú‚Çä·µÄ)</span>

<span class="sd">        p([x‚Çú, x‚Çä]| x‚Çã) = p(x‚Çä| x‚Çú)p(x‚Çú|x‚Çã)</span>
<span class="sd">                      = ùìù([A‚Çã‚Çúx‚Çã, A‚Çã‚Çäx‚Çã]·µÄ, [[ Q‚Çã‚Çú, Q‚Çã‚ÇúA‚Çú‚Çä·µÄ],</span>
<span class="sd">                                             [ A‚Çú‚ÇäQ‚Çã‚Çú, Q‚Çã‚Çä ]]</span>

<span class="sd">        Given this joint distribution we can obtain the mean and covariance of the</span>
<span class="sd">        conditional distribution of</span>
<span class="sd">        p(x‚Çú|[x‚Çã, x‚Çä]) = ùìù(x‚Çú; A‚Çã‚Çúx‚Çã + Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬π(x‚Çä - A‚Çã‚Çäx‚Çã), Q‚Çã‚Çú - Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πA‚Çú‚ÇäQ‚Çã‚Çú)</span>
<span class="sd">                       = ùìù(x‚Çú; (A‚Çã‚Çú - Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πA‚Çã‚Çä)x‚Çã + Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πx‚Çä,</span>
<span class="sd">                                (Q‚Çã‚Çú‚Åª¬π + A‚Çú‚Çä·µÄQ‚Çú‚Çä‚Åª¬πA‚Çú‚Çä)‚Åª¬π)</span>

<span class="sd">    :param state_transitions_to_t: the state transitions from t‚Çã to t - A‚Çã‚Çú</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">    :param process_covariances_to_t: the process covariances from t‚Çã to t - Q‚Çã‚Çú</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">    :param state_transitions_from_t: the state transitions from t to t‚Çä - A‚Çã‚Çú</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">    :param process_covariances_from_t: the process covariances from t to t‚Çä - Q‚Çú‚Çä</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">    :param return_precision: bool, defaults to False.</span>
<span class="sd">            if True (resp. False), conditional precision (resp. covariance) is returned</span>
<span class="sd">    :return: parameters for the conditional mean and covariance</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_tp_Q_mt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">state_transitions_from_t</span><span class="p">,</span> <span class="n">process_covariances_to_t</span><span class="p">)</span>
    <span class="n">Q_mt</span> <span class="o">=</span> <span class="n">process_covariances_from_t</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
        <span class="n">state_transitions_from_t</span><span class="p">,</span> <span class="n">A_tp_Q_mt</span><span class="p">,</span> <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">chol_Q_mt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Q_mt</span><span class="p">)</span>  <span class="c1"># L</span>

    <span class="c1"># V = L‚Åª¬π A‚Çú‚ÇäQ‚Çã‚Çú</span>
    <span class="n">L_inv_A_tp_Q_mt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">triangular_solve</span><span class="p">(</span>
        <span class="n">chol_Q_mt</span><span class="p">,</span> <span class="n">state_transitions_from_t</span> <span class="o">@</span> <span class="n">process_covariances_to_t</span>
    <span class="p">)</span>

    <span class="c1"># E = Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬π</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">triangular_solve</span><span class="p">(</span><span class="n">chol_Q_mt</span><span class="p">,</span> <span class="n">L_inv_A_tp_Q_mt</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">state_transitions_to_t</span> <span class="o">-</span> <span class="n">E</span> <span class="o">@</span> <span class="n">state_transitions_from_t</span> <span class="o">@</span> <span class="n">state_transitions_to_t</span>

    <span class="c1"># Return the parameters for the conditional density:</span>
    <span class="c1">#   p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çô @ [x‚Çã, x‚Çä], T [or T‚Åª¬π])</span>
    <span class="k">if</span> <span class="n">return_precision</span><span class="p">:</span>
        <span class="n">chol_Q_mt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">process_covariances_to_t</span><span class="p">)</span>
        <span class="n">chol_Q_tp</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">process_covariances_from_t</span><span class="p">)</span>
        <span class="n">state_dim</span> <span class="o">=</span> <span class="n">state_transitions_to_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">identities</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">default_float</span><span class="p">()),</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">process_covariances_to_t</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">Q_mt_inv</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">chol_Q_mt</span><span class="p">,</span> <span class="n">identities</span><span class="p">)</span>
        <span class="n">L_tp_inv_A_tp</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">triangular_solve</span><span class="p">(</span><span class="n">chol_Q_tp</span><span class="p">,</span> <span class="n">state_transitions_from_t</span><span class="p">)</span>
        <span class="c1"># The conditional_precision T‚Åª¬π = Q‚Çã‚Çú‚Åª¬π + A‚Çú‚Çä·µÄQ‚Çú‚Çä‚Åª¬πA‚Çú‚Çä</span>
        <span class="n">T_inv</span> <span class="o">=</span> <span class="n">Q_mt_inv</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">L_tp_inv_A_tp</span><span class="p">,</span> <span class="n">L_tp_inv_A_tp</span><span class="p">,</span> <span class="n">transpose_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">T_inv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The conditional_covariance T = Q‚Çã‚Çú - Q‚Çã‚ÇúA‚Çú‚Çä·µÄQ‚Çã‚Çä‚Åª¬πA‚Çú‚ÇäQ‚Çã‚Çú == Q‚Çã‚Çú - Q‚Çã‚Çú·µÄA‚Çú‚Çä·µÄL‚Åª·µÄL‚Åª¬πA‚Çú‚ÇäQ‚Çã‚Çú</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">process_covariances_to_t</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">L_inv_A_tp_Q_mt</span><span class="p">,</span> <span class="n">L_inv_A_tp_Q_mt</span><span class="p">,</span> <span class="n">transpose_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">T</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="_conditional_statistics"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals._conditional_statistics">[docs]</a><span class="k">def</span> <span class="nf">_conditional_statistics</span><span class="p">(</span>
    <span class="n">new_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">training_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">SDEKernel</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ‚àÄ x‚Çú ‚àà new_time_points, computes the statistics P‚Çú and T‚Çú of the conditional densities:</span>
<span class="sd">        p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)</span>
<span class="sd">    where</span>
<span class="sd">      - p is the density over state trajectories specified by the kernel</span>
<span class="sd">      - ‚àÄ x‚Çú ‚àà new_time_points</span>
<span class="sd">             x‚Çä = arg min‚Çì { |x-x‚Çú|, x ‚àà training_time_point and x&gt;x‚Çú }</span>
<span class="sd">             x‚Çã = arg min‚Çì { |x-x‚Çú|, x ‚àà training_time_point and x‚©Ωx‚Çú }</span>

<span class="sd">    Warning: `new_time_points` and `training_time_points` must be sorted</span>

<span class="sd">    :param new_time_points: sorted time points to generate observations for</span>
<span class="sd">            ``batch_shape + [num_new_time_points,]``</span>
<span class="sd">    :param training_time_points: sorted time points to condition on</span>
<span class="sd">            ``batch_shape + [num_training_time_points,]``</span>
<span class="sd">    :param kernel: a Markovian Kernel</span>
<span class="sd">    :return: parameters for the conditional mean and covariance, and the insertion indices</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim, 2*state_dim]``</span>
<span class="sd">            ``batch_shape + [num_new_time_points, state_dim, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_new_time_points,]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_shape</span> <span class="o">=</span> <span class="n">new_time_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">batch_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_shape</span><span class="p">)</span>
    <span class="c1"># Indices of where the intermediate points would be inserted into the</span>
    <span class="c1"># existing time points. This will be slow if new_time_points are not sorted.</span>
    <span class="c1"># WARNING: tf.searchsorted will be slow if `new_time_points` are not sorted</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">training_time_points</span><span class="p">,</span> <span class="n">new_time_points</span><span class="p">)</span>
    <span class="c1"># HACK - arbitrary far away point</span>
    <span class="n">inf</span> <span class="o">=</span> <span class="n">APPROX_INF</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">training_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">time_points_augmented</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">training_time_points</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># For all intermediate_time_points calculate the time deltas from the previous time_point</span>
    <span class="c1"># (delta_time_points_1) and to the next time_point (delta_time_points_2)</span>
    <span class="n">inducing_plus</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">time_points_augmented</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">)</span>
    <span class="n">inducing_minus</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">time_points_augmented</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="n">batch_dims</span><span class="p">)</span>

    <span class="n">dX_mt</span> <span class="o">=</span> <span class="n">new_time_points</span> <span class="o">-</span> <span class="n">inducing_minus</span>
    <span class="n">dX_tp</span> <span class="o">=</span> <span class="n">inducing_plus</span> <span class="o">-</span> <span class="n">new_time_points</span>
    <span class="n">A_mt</span><span class="p">,</span> <span class="n">Q_mt</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">transition_statistics</span><span class="p">(</span><span class="n">transition_times</span><span class="o">=</span><span class="n">inducing_minus</span><span class="p">,</span> <span class="n">time_deltas</span><span class="o">=</span><span class="n">dX_mt</span><span class="p">)</span>
    <span class="n">A_tp</span><span class="p">,</span> <span class="n">Q_tp</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">transition_statistics</span><span class="p">(</span><span class="n">transition_times</span><span class="o">=</span><span class="n">new_time_points</span><span class="p">,</span> <span class="n">time_deltas</span><span class="o">=</span><span class="n">dX_tp</span><span class="p">)</span>
    <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">_conditional_statistics_from_transitions</span><span class="p">(</span><span class="n">A_mt</span><span class="p">,</span> <span class="n">Q_mt</span><span class="p">,</span> <span class="n">A_tp</span><span class="p">,</span> <span class="n">Q_tp</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Return the parameters for the conditional density:</span>
    <span class="c1">#   p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çô @ [x‚Çã, x‚Çä], T)</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">indices</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="cyclic_reduction_conditional_statistics"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals.cyclic_reduction_conditional_statistics">[docs]</a><span class="k">def</span> <span class="nf">cyclic_reduction_conditional_statistics</span><span class="p">(</span>
    <span class="n">explained_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">conditioning_time_points</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">SDEKernel</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute :math:`F‚Çú, G‚Çú, L‚Çú`. Such that:</span>

<span class="sd">    .. math:: p(x·µâ‚Çú | x·∂ú‚Çú‚Çã‚ÇÅ,  x·∂ú‚Çú‚Çä‚ÇÅ) = ùìù(x·µâ‚Çú; F‚Çú @ x·∂ú‚Çú‚Çã‚ÇÅ + G‚Çú @ x·∂ú‚Çú‚Çä‚ÇÅ, T‚Çú = (L‚Çú L‚Çú·µÄ)‚Åª¬π = L‚Çú‚Åª·µÄL‚Çú‚Åª¬π)</span>

<span class="sd">    ...where superscripts :math:`e` and :math:`c` refer to explained and conditioning respectively.</span>

<span class="sd">    .. note:: :math:`x·µâ` and :math:`x·∂ú` must be sorted, such that:</span>

<span class="sd">        .. math:: x·µâ‚ÇÄ &lt; x·∂ú‚ÇÄ &lt; x·µâ‚ÇÅ &lt; ...  &lt; x·µâ‚Çú &lt; x·∂ú‚Çú &lt; x·∂ú‚Çú‚Çä‚ÇÅ &lt; x·∂ú‚Çú‚Çä‚ÇÅ &lt; ...</span>

<span class="sd">        ...where :math:`len(x·µâ) = len(x·∂ú)` or :math:`len(x·µâ) = len(x·∂ú) + 1`.</span>

<span class="sd">    This computes the conditional statistics :math:`F‚Çú, G‚Çú, L‚Çú`, where</span>
<span class="sd">    :math:`ùîº x·µâ|x·∂ú = - L‚Åª·µÄ U·µÄ x·∂ú`, with::</span>

<span class="sd">        U·µÄ = | F‚ÇÅ·µÄ                 [      |]  and  L‚Åª·µÄ = |L‚ÇÅ‚Åª·µÄ               |</span>
<span class="sd">             |  G‚ÇÅ·µÄ, F‚ÇÇ·µÄ           [      |]             |   L‚ÇÇ‚Åª·µÄ            |</span>
<span class="sd">             |     , G‚ÇÇ·µÄ,‚ã±         [      |]             |      L‚ÇÉ‚Åª·µÄ         |</span>
<span class="sd">             |           ‚ã± ‚ã±       [      |]             |        ‚ã±          |</span>
<span class="sd">             |             ‚ã± F‚Çô‚Çã‚ÇÅ·µÄ [      |]             |          ‚ã±        |</span>
<span class="sd">             |               G‚Çô‚Çã‚ÇÅ·µÄ [ F‚Çô·µÄ  |]             |            L‚Çô‚Åª·µÄ   |</span>

<span class="sd">    :math:`L` is the Cholesky factor of the conditional precision :math:`x·µâ|x·∂ú`.</span>

<span class="sd">    Statistics :math:`F` and :math:`G` are computed from the conditional mean projection</span>
<span class="sd">    parameters :math:`D` and :math:`E` defined by :math:`ùîº x·µâ‚Çô|x·∂ú = D‚Çô @ x·∂ú‚Çô‚Çã‚ÇÅ + E‚Çô @ x·∂ú‚Çô`.</span>

<span class="sd">    Solving the system :math:`- (L‚Åª·µÄ U·µÄ x·∂ú)‚Çô = D‚Çô @ x·∂ú‚Çô‚Çã‚ÇÅ + E‚Çô @ x·∂ú‚Çô`,</span>
<span class="sd">    we get :math:`G‚Çô‚Çã‚ÇÅ·µÄ = -L‚Çô·µÄ D‚Çô` and :math:`F‚Çô·µÄ = -L‚Çô·µÄ E‚Çô`.</span>

<span class="sd">    Details of the system::</span>

<span class="sd">        -| L‚ÇÅ‚Åª·µÄF‚ÇÅ·µÄ x·∂ú‚ÇÅ                     | = | E‚ÇÅ x·∂ú‚ÇÅ</span>
<span class="sd">         | L‚ÇÇ‚Åª·µÄG‚ÇÅ·µÄx·∂ú‚ÇÅ  + L‚ÇÇ‚Åª·µÄ F‚ÇÇ·µÄ x·∂ú‚ÇÇ      |   | D‚ÇÇ x·∂ú‚ÇÅ +   E‚ÇÇ x·∂ú‚ÇÇ</span>
<span class="sd">         | L‚ÇÉ‚Åª·µÄ G‚ÇÇ·µÄ x·∂ú‚ÇÇ , L‚ÇÉ‚Åª·µÄ F‚ÇÉ·µÄ x·∂ú‚ÇÉ,    |   | D‚ÇÉ x·∂ú‚ÇÇ +   E‚ÇÉ x·∂ú‚ÇÉ</span>
<span class="sd">         | ‚ãÆ                               |   | ‚ãÆ</span>
<span class="sd">         | L‚Çô‚Åª·µÄ G‚Çô‚Çã‚ÇÅ·µÄx·∂ú‚Çô‚Çã‚ÇÅ,   L‚Çô‚Åª·µÄ [F‚Çô·µÄ]x·∂ú‚Çô|   | D‚Çô x·∂ú‚Çô‚Çã‚ÇÅ +   [E‚Çô] x·∂ú‚Çô</span>

<span class="sd">    Remarks on size:</span>

<span class="sd">    * When splitting :math:`x` of size :math:`n` into odd and even, you get</span>
<span class="sd">      :math:`n·µâ = (n+1)//2` and :math:`n·∂ú = n//2`</span>
<span class="sd">    * At each level, cyclic reduction statistics have shape:</span>

<span class="sd">      .. math::</span>
<span class="sd">         &amp;- F : n·∂ú\\</span>
<span class="sd">         &amp;- G : n·µâ - 1\\</span>
<span class="sd">         &amp;- L : n·µâ\\</span>

<span class="sd">    Note that:</span>

<span class="sd">        * :math:`F‚ÇÄ` is not defined (there is no time point below :math:`x·µâ‚ÇÄ`)</span>
<span class="sd">        * The last element :math:`G` may not be defined if :math:`len(x·µâ) = len(x·∂ú)`</span>

<span class="sd">    :param explained_time_points: Sorted time points to generate observations for, with shape</span>
<span class="sd">            ``batch_shape + [num_time_points_1,]``.</span>
<span class="sd">    :param conditioning_time_points: Sorted time points to condition on, with shape</span>
<span class="sd">            ``batch_shape + [num_time_points_2,]``.</span>
<span class="sd">    :param kernel:  A kernel.</span>
<span class="sd">    :return: Parameters for the conditional, with respective shapes</span>
<span class="sd">            ``batch_shape + [num_conditioning, state_dim, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_explained - 1, state_dim, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_explained, state_dim, state_dim]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta_t1</span> <span class="o">=</span> <span class="n">explained_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">explained_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">delta_t2</span> <span class="o">=</span> <span class="n">conditioning_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">conditioning_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_non_negative</span><span class="p">(</span><span class="n">delta_t1</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;explained_time_points must be sorted&quot;</span><span class="p">)</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_non_negative</span><span class="p">(</span><span class="n">delta_t2</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;conditioning_time_points must be sorted&quot;</span><span class="p">)</span>

    <span class="n">num_explained</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">explained_time_points</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_conditioning</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">conditioning_time_points</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_greater_equal</span><span class="p">(</span>
        <span class="n">num_explained</span><span class="p">,</span>
        <span class="n">num_conditioning</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;explained_time_points must be longer than conditioning_time_points&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_less_equal</span><span class="p">(</span>
        <span class="n">num_explained</span> <span class="o">-</span> <span class="n">num_conditioning</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;explained_time_points must be as long as conditioning_time_points&quot;</span>
        <span class="s2">&quot; or 1 entry longer&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Indices of where the intermediate points would be inserted into the</span>
    <span class="c1"># existing time points. This will be slow if new_time_points are not sorted.</span>
    <span class="c1"># HACK - arbitrary far away point</span>
    <span class="n">inf</span> <span class="o">=</span> <span class="n">APPROX_INF</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">conditioning_time_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">time_points_augmented</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">conditioning_time_points</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># For all intermediate_time_points calculate the time deltas from the previous time_point</span>
    <span class="c1"># (delta_time_points_1) and to the next time_point (delta_time_points_2)</span>

    <span class="c1"># this will span the range -inf to either the penultimate or last time points</span>
    <span class="n">left_conditioning_time_points</span> <span class="o">=</span> <span class="n">time_points_augmented</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_explained</span><span class="p">]</span>
    <span class="n">dX_mt</span> <span class="o">=</span> <span class="n">explained_time_points</span> <span class="o">-</span> <span class="n">left_conditioning_time_points</span>
    <span class="c1"># this will span the range from the first time point to either the last or inf</span>
    <span class="n">right_conditioning_time_points</span> <span class="o">=</span> <span class="n">time_points_augmented</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">num_explained</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">dX_tp</span> <span class="o">=</span> <span class="n">right_conditioning_time_points</span> <span class="o">-</span> <span class="n">explained_time_points</span>
    <span class="n">A_mt</span><span class="p">,</span> <span class="n">Q_mt</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">transition_statistics</span><span class="p">(</span>
        <span class="n">transition_times</span><span class="o">=</span><span class="n">left_conditioning_time_points</span><span class="p">,</span> <span class="n">time_deltas</span><span class="o">=</span><span class="n">dX_mt</span>
    <span class="p">)</span>
    <span class="n">A_tp</span><span class="p">,</span> <span class="n">Q_tp</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">transition_statistics</span><span class="p">(</span>
        <span class="n">transition_times</span><span class="o">=</span><span class="n">explained_time_points</span><span class="p">,</span> <span class="n">time_deltas</span><span class="o">=</span><span class="n">dX_tp</span>
    <span class="p">)</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">T_inv</span> <span class="o">=</span> <span class="n">_conditional_statistics_from_transitions</span><span class="p">(</span>
        <span class="n">A_mt</span><span class="p">,</span> <span class="n">Q_mt</span><span class="p">,</span> <span class="n">A_tp</span><span class="p">,</span> <span class="n">Q_tp</span><span class="p">,</span> <span class="n">return_precision</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">T_inv</span><span class="p">)</span>

    <span class="c1"># Return the parameters for the cyclic reduction parameters:</span>
    <span class="n">F</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">transpose_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">transpose_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">G</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_conditioning</span><span class="p">],</span> <span class="n">L</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="base_conditional_predict"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals.base_conditional_predict">[docs]</a><span class="k">def</span> <span class="nf">base_conditional_predict</span><span class="p">(</span>
    <span class="n">conditional_projections</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">conditional_covariances</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">adjacent_states</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">pairwise_state_covariances</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict state at new time points given conditional statistics.</span>

<span class="sd">    Given conditionals statistics :math:`P‚Çú, T‚Çú` of :math:`p(x‚Çú|x‚Çã, x‚Çä) = ùìù(P‚Çú @ [x‚Çã, x‚Çä], T‚Çú)`</span>
<span class="sd">    and pairwise marginals :math:`p(x‚Çú‚Çã, x‚Çú‚Çä) = ùìù(m‚Çú, S‚Çú)`,</span>
<span class="sd">    compute marginal mean and covariance of the marginal density:</span>

<span class="sd">    .. math:: p(x‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú + P‚Çú S‚Çú P‚Çú·µÄ)</span>

<span class="sd">    If :math:`S‚Çú` is not provided, compute the conditional mean and covariance of the</span>
<span class="sd">    conditional density:</span>

<span class="sd">    .. math:: p(x‚Çú|[x‚Çú‚Çã, x‚Çú‚Çä] = m‚Çú) = ùìù(P‚Çú m‚Çú, T‚Çú)</span>

<span class="sd">    :param conditional_projections: :math:`P‚Çú` with shape</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim]``.</span>
<span class="sd">    :param conditional_covariances: :math:`T‚Çú` with shape</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``.</span>
<span class="sd">    :param adjacent_states: Pairs of states to condition on, with shape</span>
<span class="sd">            ``batch_shape + [num_time_points, 2 * state_dim]``.</span>
<span class="sd">    :param pairwise_state_covariances: Covariances of the pairs of states to condition on,</span>
<span class="sd">            with shape ``batch_shape + [num_time_points, 2 * state_dim, 2 * state_dim]``.</span>
<span class="sd">    :return: Predicted mean and covariance for the time points, with respective shapes</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_time_points, state_dim, state_dim]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">means</span> <span class="o">=</span> <span class="p">(</span><span class="n">conditional_projections</span> <span class="o">@</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">adjacent_states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">covs</span> <span class="o">=</span> <span class="n">conditional_covariances</span>
    <span class="k">if</span> <span class="n">pairwise_state_covariances</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">covs</span> <span class="o">+=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">conditional_projections</span> <span class="o">@</span> <span class="n">pairwise_state_covariances</span><span class="p">,</span>
            <span class="n">conditional_projections</span><span class="p">,</span>
            <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">means</span><span class="p">,</span> <span class="n">covs</span></div>


<span class="nd">@tf_scope_fn_decorator</span>
<div class="viewcode-block" id="pairwise_marginals"><a class="viewcode-back" href="../../autoapi/markovflow/conditionals/index.html#markovflow.conditionals.pairwise_marginals">[docs]</a><span class="k">def</span> <span class="nf">pairwise_marginals</span><span class="p">(</span>
    <span class="n">dist</span><span class="p">:</span> <span class="n">GaussMarkovDistribution</span><span class="p">,</span> <span class="n">initial_mean</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">initial_covariance</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO(sam): figure out what the initial mean and covariance should be for non-stationary kernels</span>

<span class="sd">    For each pair of subsequent states :math:`x‚Çñ, x‚Çñ‚Çä‚ÇÅ`, return the mean and covariance of</span>
<span class="sd">    their joint distribution. This is assuming we start from, and revert to, the prior:</span>

<span class="sd">    .. math::</span>
<span class="sd">        &amp;p(x‚Çñ) = ùìù(Œº‚Çñ, P‚Çñ)  \verb|(we can get this from the marginals method)|\\</span>
<span class="sd">        &amp;p(x‚Çñ‚Çä‚ÇÅ | x‚Çñ) = ùìù(A‚ÇñŒº‚Çñ, Q‚Çñ)</span>

<span class="sd">    Then:</span>

<span class="sd">    .. math::</span>
<span class="sd">        p(x‚Çñ‚Çä‚ÇÅ, x‚Çñ) = ùìù([Œº‚Çñ, Œº‚Çñ‚Çä‚ÇÅ], [P‚Çñ, P‚Çñ A‚Çñ·µÄ])\\</span>
<span class="sd">                                     [A‚Çñ P‚Çñ, P‚Çñ‚Çä‚ÇÅ]</span>

<span class="sd">    :param dist: The distribution.</span>
<span class="sd">    :param initial_mean:  The prior mean (used to extend the pairwise marginals</span>
<span class="sd">        of the distribution).</span>
<span class="sd">    :param initial_covariance: The prior covariance (used to extend the pairwise marginal of</span>
<span class="sd">        the state space model).</span>
<span class="sd">    :return: Mean and covariance pairs for the marginals, with respective shapes</span>
<span class="sd">            ``batch_shape + [num_transitions + 2, state_dim]``</span>
<span class="sd">            ``batch_shape + [num_transitions + 2, state_dim, state_dim]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">means</span><span class="p">,</span> <span class="n">covariances</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">marginals</span>
    <span class="n">covariances</span><span class="p">,</span> <span class="n">subsequent_covariances</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">covariance_blocks</span><span class="p">()</span>

    <span class="n">initial_mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">initial_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">extended_means</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">initial_mean</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">initial_mean</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">joint_mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">extended_means</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">extended_means</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">initial_covariance</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">extended_cov</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">initial_covariance</span><span class="p">,</span> <span class="n">covariances</span><span class="p">,</span> <span class="n">initial_covariance</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">extended_subsequent_cov</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">initial_covariance</span><span class="p">),</span>
            <span class="n">subsequent_covariances</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">initial_covariance</span><span class="p">),</span>
        <span class="p">],</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">joint_cov_0</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">extended_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="n">extended_subsequent_cov</span><span class="p">)],</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">joint_cov_1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">extended_subsequent_cov</span><span class="p">,</span> <span class="n">extended_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">joint_cov</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">joint_cov_0</span><span class="p">,</span> <span class="n">joint_cov_1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dist</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">,</span> <span class="p">[</span><span class="n">dist</span><span class="o">.</span><span class="n">num_transitions</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dist</span><span class="o">.</span><span class="n">state_dim</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">shape_cov</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">shape</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dist</span><span class="o">.</span><span class="n">state_dim</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">joint_mean</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">debugging</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">joint_cov</span><span class="p">),</span> <span class="n">shape_cov</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">joint_mean</span><span class="p">,</span> <span class="n">joint_cov</span></div>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright Copyright 2021 The markovflow Contributors

Licensed under the Apache License, Version 2.0
.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>